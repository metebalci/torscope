#!/usr/bin/env python3
"""
Download and parse Tor directory authorities and fallback directories.

This script fetches auth_dirs.inc and fallback_dirs.inc from the Tor
source repository and generates Python code with hardcoded data.

Run this script when the upstream files change (rarely - years apart).

Usage:
    python scripts/update_authorities.py
"""

import re
import sys
from pathlib import Path

import httpx

# URLs for source files
AUTH_URL = "https://gitlab.torproject.org/tpo/core/tor/-/raw/main/src/app/config/auth_dirs.inc"
FALLBACK_URL = "https://gitlab.torproject.org/tpo/core/tor/-/raw/main/src/app/config/fallback_dirs.inc"

# Output files
OUTPUT_DIR = Path(__file__).parent.parent / "src" / "torscope" / "directory"
AUTHORITY_FILE = OUTPUT_DIR / "authority.py"
FALLBACK_FILE = OUTPUT_DIR / "fallback.py"


def fetch_file(url: str) -> str:
    """Fetch a file from URL."""
    print(f"Fetching {url}...")
    response = httpx.get(url, timeout=30, follow_redirects=True)
    response.raise_for_status()
    return response.text


def parse_authorities(content: str) -> list[dict]:
    """Parse auth_dirs.inc content."""
    authorities = []

    # Join continuation lines
    lines = []
    current = ""
    for line in content.split("\n"):
        line = line.strip()
        if not line or line.startswith("//") or line.startswith("/*"):
            continue
        current += line
        if line.endswith(","):
            lines.append(current)
            current = ""

    for line in lines:
        # Skip bridge authorities
        if "bridge" in line.lower():
            continue

        # Extract nickname
        nick_match = re.search(r'"(\w+)\s+orport=', line)
        if not nick_match:
            continue
        nickname = nick_match.group(1)

        # Extract orport
        orport_match = re.search(r"orport=(\d+)", line)
        orport = int(orport_match.group(1)) if orport_match else 0

        # Extract v3ident
        v3ident_match = re.search(r"v3ident=([A-F0-9]+)", line)
        if not v3ident_match:
            continue
        v3ident = v3ident_match.group(1)

        # Extract IPv4 address and dirport
        ipv4_match = re.search(r'"?\s*(\d+\.\d+\.\d+\.\d+):(\d+)', line)
        if not ipv4_match:
            continue
        ip = ipv4_match.group(1)
        dirport = int(ipv4_match.group(2))

        # Extract IPv6 address if present
        ipv6_match = re.search(r"\[([0-9a-fA-F:]+)\]:(\d+)", line)
        ipv6 = f"[{ipv6_match.group(1)}]:{ipv6_match.group(2)}" if ipv6_match else None

        authorities.append({
            "nickname": nickname,
            "ip": ip,
            "dirport": dirport,
            "orport": orport,
            "v3ident": v3ident,
            "ipv6": ipv6,
        })
        print(f"  Authority: {nickname} ({ip}:{dirport})")

    return authorities


def parse_fallbacks(content: str) -> list[dict]:
    """Parse fallback_dirs.inc content."""
    fallbacks = []

    # Each entry is like:
    # "1.2.3.4 orport=443 id=ABCD..."
    # " ipv6=[...]:443"  (optional)
    # /* nickname=Name */
    # ,

    # Split by entries (each ends with a comma on its own line or after */)
    entries = re.split(r",\s*\n", content)

    for entry in entries:
        entry = entry.strip()
        if not entry or entry.startswith("/*"):
            continue

        # Extract IPv4 and orport
        ip_match = re.search(r'"(\d+\.\d+\.\d+\.\d+)\s+orport=(\d+)', entry)
        if not ip_match:
            continue
        ip = ip_match.group(1)
        orport = int(ip_match.group(2))

        # Extract fingerprint (id=)
        id_match = re.search(r"id=([A-F0-9]+)", entry)
        if not id_match:
            continue
        fingerprint = id_match.group(1)

        # Extract IPv6 if present
        ipv6_match = re.search(r'ipv6=\[([0-9a-fA-F:]+)\]:(\d+)', entry)
        ipv6 = f"[{ipv6_match.group(1)}]:{ipv6_match.group(2)}" if ipv6_match else None

        # Extract nickname from comment
        nick_match = re.search(r"nickname=(\w+)", entry)
        nickname = nick_match.group(1) if nick_match else None

        fallbacks.append({
            "ip": ip,
            "orport": orport,
            "fingerprint": fingerprint,
            "ipv6": ipv6,
            "nickname": nickname,
        })

    print(f"  Found {len(fallbacks)} fallback directories")
    return fallbacks


def generate_authority_code(authorities: list[dict]) -> str:
    """Generate authority.py content."""
    code = '''"""
Directory authority information.

This file is auto-generated by scripts/update_authorities.py
Do not edit manually.
"""

from dataclasses import dataclass


@dataclass
class DirectoryAuthority:
    """Directory authority information."""

    nickname: str
    ip: str
    dirport: int
    orport: int
    v3ident: str  # hex fingerprint
    ipv6_address: str | None = None

    @property
    def http_url(self) -> str:
        """Get base HTTP URL for directory requests."""
        return f"http://{self.ip}:{self.dirport}"

    @property
    def address(self) -> str:
        """Get formatted address string."""
        return f"{self.ip}:{self.dirport}"


DIRECTORY_AUTHORITIES = [
'''

    for auth in authorities:
        code += f'''    DirectoryAuthority(
        nickname="{auth['nickname']}",
        ip="{auth['ip']}",
        dirport={auth['dirport']},
        orport={auth['orport']},
        v3ident="{auth['v3ident']}",
'''
        if auth.get("ipv6"):
            code += f'        ipv6_address="{auth["ipv6"]}",\n'
        code += "    ),\n"

    code += ''']


def get_authorities() -> list[DirectoryAuthority]:
    """Get list of directory authorities."""
    return DIRECTORY_AUTHORITIES


def get_authority_by_nickname(nickname: str) -> DirectoryAuthority | None:
    """Get directory authority by nickname (case-insensitive)."""
    for auth in DIRECTORY_AUTHORITIES:
        if auth.nickname.lower() == nickname.lower():
            return auth
    return None


def get_random_authority() -> DirectoryAuthority:
    """Get a random directory authority."""
    import random

    return random.choice(DIRECTORY_AUTHORITIES)


def get_shuffled_authorities() -> list[DirectoryAuthority]:
    """Get all directory authorities in random order."""
    import random

    authorities = list(DIRECTORY_AUTHORITIES)
    random.shuffle(authorities)
    return authorities
'''

    return code


def generate_fallback_code(fallbacks: list[dict]) -> str:
    """Generate fallback.py content."""
    code = '''"""
Fallback directory information.

This file is auto-generated by scripts/update_authorities.py
Do not edit manually.

Fallback directories are stable relays that can be used for
bootstrapping when directory authorities are unreachable.
"""

from dataclasses import dataclass


@dataclass
class FallbackDirectory:
    """Fallback directory information."""

    ip: str
    orport: int
    fingerprint: str  # hex fingerprint
    nickname: str | None = None
    ipv6_address: str | None = None

    @property
    def address(self) -> str:
        """Get formatted address string."""
        return f"{self.ip}:{self.orport}"


FALLBACK_DIRECTORIES = [
'''

    for fb in fallbacks:
        code += f'''    FallbackDirectory(
        ip="{fb['ip']}",
        orport={fb['orport']},
        fingerprint="{fb['fingerprint']}",
'''
        if fb.get("nickname"):
            code += f'        nickname="{fb["nickname"]}",\n'
        if fb.get("ipv6"):
            code += f'        ipv6_address="{fb["ipv6"]}",\n'
        code += "    ),\n"

    code += ''']


def get_fallbacks() -> list[FallbackDirectory]:
    """Get list of fallback directories."""
    return FALLBACK_DIRECTORIES


def get_random_fallback() -> FallbackDirectory:
    """Get a random fallback directory."""
    import random

    return random.choice(FALLBACK_DIRECTORIES)


def get_shuffled_fallbacks() -> list[FallbackDirectory]:
    """Get all fallback directories in random order."""
    import random

    fallbacks = list(FALLBACK_DIRECTORIES)
    random.shuffle(fallbacks)
    return fallbacks
'''

    return code


def main() -> int:
    """Main entry point."""
    try:
        # Fetch files
        auth_content = fetch_file(AUTH_URL)
        fallback_content = fetch_file(FALLBACK_URL)

        # Parse
        print("\nParsing authorities...")
        authorities = parse_authorities(auth_content)
        if not authorities:
            print("Error: No authorities found", file=sys.stderr)
            return 1

        print("\nParsing fallbacks...")
        fallbacks = parse_fallbacks(fallback_content)
        if not fallbacks:
            print("Error: No fallbacks found", file=sys.stderr)
            return 1

        # Generate code
        print("\nGenerating code...")
        authority_code = generate_authority_code(authorities)
        fallback_code = generate_fallback_code(fallbacks)

        # Write files
        AUTHORITY_FILE.write_text(authority_code)
        print(f"  Written: {AUTHORITY_FILE}")

        FALLBACK_FILE.write_text(fallback_code)
        print(f"  Written: {FALLBACK_FILE}")

        print(f"\nDone! {len(authorities)} authorities, {len(fallbacks)} fallbacks")
        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
